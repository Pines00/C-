### 项目准备

#### 用户如何与web服务器进行通信

浏览器根据IP地址与端口号，向服务器发送一个http请求。这一过程首先要通过TCP协议的三次握手尽力与目标web服务器进行连接，然后http协议生成针对目标web服务器的HTTP请求报文，通过TCP、IP协议发送到目标web服务器上

#### web服务器如何接收客户端发送来的http请求报文

服务器通过socket监听来自用户的请求，其中SO_REUSEADDR允许端口被重复使用

监听socket listen到新的客户连接并放入监听队列，我们都需要告诉服务器有连接，并分配一个连接单元来处理这个用户请求。而且处理这个请求的同时还要继续监听其他客户的请求并分配其另一逻辑单元来处理（并发）。服务器通过epoll来对监听socket和连接socket同时监听。epoll虽然可以同时监听多个fd，但是本身是阻塞的，并且当有多个fd同时就绪的时候，如果不采取额外措施，程序只能按顺序处理其中就绪的每一个fd，所以为了提高效率，这部分通过线程池来实现，为每一个就绪fd分配一个线程来处理。

服务器通常需要处理三类事件：I/O事件，信号及定时事件；有两种事件处理模式

* reactor：要求主线程，只负责监听文件描述符上是否有事件发生（可读可写），若有，则立即通知工作线程，将socket可读可写事件放入请求队列，交给工作线程处理。
* Proactor：将所有的I/O操作都交给主线程和内核来处理（进行读和写），工作线程仅负责处理逻辑，比如主线程读完后，选择一个工作线程来处理客户请求`users[sockfd].read()    ----->pool->append(users+sockfd)`;

通常使用同步I/O模型实现reactor，使用异步I/O实现proactor。这个项目中使用的是同步I/O模拟的proactor事件处理模式。

* 同步（阻塞）I/O：在一个线程中，一旦遇到io操作，就需要等待I/O操作完成才能继续下一步操作。
* 异步（非阻塞）I/O：当代码执行一个耗时的io操作时，它只发出io指令，并不等待IO结果，然后就去执行其他代码，当io结果返回时，再通知CPU进行处理。

**三种复用方式为什么要用epoll以及他们之间的区别**

* 对于select和poll，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符都需要执行一个系统调用。系统调用开销比较大，而且在很多短期活跃连接的时候，epoll可能会慢于select和poll
* select使用线性表描述符文件描述符集合，文件描述符有上限，poll使用的是链表；epoll底层通过的是红黑树，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait之后，仅观察这个list中有没有数据即可。
* select和poll最大开销就来自内核判断是否有文件描述符就绪这一过程：每次都是通过整体遍历的方式，判断fd是否有活动；epoll则不需要，当有活动产生时，自动触发epoll回调函数通知epoll文件描述符，然后内核讲这些就绪的文件描述符放到ready list，只要遍历维护的ready list。
* select和poll都只能工作在相对低效的LT（一个事件触发多次）模式，而epoll同时支持LT和ET（只触发一次）模式
* 当检测fd数量较小，且各个fd都很活跃的情况下，使用select 和poll，当监听fd数量多，且单位时间仅部分活跃的情况下，使用epoll较好



epoll对fd操作方式有两种LT，ET，二者区别在于调用epoll_wait时候，内核发生什么：

* LT：类似select，LT会去遍历在epoll事件表中每个文件描述符，来观察是否有事件发生，如果有（出发了fd上的回调函数），epoll_wait就会以非阻塞的方式返回，若该epoll事件没有被处理完，该事件还会被后续的epoll_wait再次触发。
* ET：在发现有事件发生后，立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束

在使用ET模式时，必须保证文件描述符是非阻塞的，并且每次调用read和write都必须等到他们返回EWOULDBLOCK（确保所有数据都已读完或写完）；

#### 4 Web服务器如何处理以及响应接收到的HTTP请求报文

该项目使用线程池（半同步半反应堆）并发处理用户请求，主线程负责读写，工作线程负责处理逻辑（HTTP请求报文的解析等）。listenfd上到达的connection通过accept()接收，并返回一个新的socket文件描述符connfd用于和用户通信，并对用户请求返回响应，同时将这个connfd注册到内核事件表中。等用户发来请求报文。这个过程是epoll_wait发现这个connfd上有可读事件（EPOLLIN），主线程就将这个HTTP的请求报文读进这个连接socket的读缓存中users[sockfd].read()，然后该任务对象插入线程池的请求队列中pool->append(users+sockfd);,

线程池：

* 线程池就是一个pthread_t类型的数组，通过pthread_create()函数创建m_thread_number个线程，用来执行worker()函数以执行每个请求处理函数（http请求的process函数），通过pthread_detach()将线程设置成脱离态，当这一线程运行结束时，他的资源会被系统自动回收，而不再需要在其他线程中对其进行pthread_join()操作。
* 操作工作队列一定要加锁，因为它被所有线程共享
* 用信号量来标识请求队列中的请求数，通过m_queuestat_wait()来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。

**为什么要使用线程池**

当你需要限制你应用程序中同时运行的线程数时，线程池非常有用，因为启动一个新线程带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，可以将这些任务传递到线程池，而不是为每个任务动态开启一个新的线程。

**read之后http请求是如何被处理的**，http入口函数process();

首先process_read()也就是对读入该connfd读缓冲区的请求报文进行解析。HTTP请求报文由请求行、头部信息、空行和请求数据四个部分组成。process_read()函数的作用是将上述例子的请求报文进行解析，因为用户的请求内容包含在这个请求报文里面，只有通过解析，知道用户请求的内容是什么，。项目中使用主从状态机进行解析，从状态机负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。每解析一部分都会将整个请求m_check_state状态改变，状态机也就是根据这个状态来进行不同部分的解析跳转的：

* 解析请求行parse_request_line(text)
* 解析请求头部parse_headers(text);
* 解析请求数据parse_content(text);

通过解析，得到一个完整的，正确的HTTP请求时，就到了do_request代码部分，需要对get请求和post请求做不同的预处理，然后分析目标文件的属性，若目标文件存在、对所有用户可读且不是目录时，则使用mmap将其映射到内存地址m_file_address处，并告诉调用者获取文件成功。

#### 数据库连接池是如何运行的

若每次用户请求都需要新建一个数据库连接，请求结束后我们释放该数据库连接，当用户请求连接过多时，这种做法过于低效，所以类似线程池的做法，构建一个数据库连接池，预先生成一些数据库连接放在那里供用户请求使用。

对于一个数据库连接池，预先生成多个这样的数据库连接，然后放在一个链表中，同时维护最大连接数、当前可用连接数、和当前已用连接数这三个变量。同样注意在对连接池操作时要用到锁机制，因为他被所有线程共享。

#### 生成HTTP响应并返回给用户

下面就是做出响应，即process_write(read_ret)这一步，函数分局process_read()的返回结果来判断应该返回给用户什么响应，假设用户请求的文件存在，而且已经被mmap到m_file_address这里，那么就将做如下写操作，将响应写到这个connfd的写缓存m_write_buf中

#### 线程池的实现

创建线程池数组pthread_t[m_thread_number];然后循环调用pthread_create来创建线程，最后将子线程与主线程分离，子线程 结束后，资源自动回收。

```
int pthread_create (pthread_t *thread_tid,                 //返回新生成的线程的id
3                    const pthread_attr_t *attr,         //指向线程属性的指针,通常设置为NULL
4                    void * (*start_routine) (void *),   //处理线程函数的地址
5                    void *arg);                         //start_routine()中的参数
函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为静态成员函数。
```

this指针的锅。

pthead_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为`(void *)`,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数`(void*)`不能匹配，不能通过编译。

静态成员函数就没有这个问题，里面没有this指针。

##### 线程池类定义

线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

##### 线程池创建与回收

构造函数中创建线程池，pthread_create函数中将累的对象作为参数传递给静态函数worker，在静态函数中引用这个对象，并调用run，

* 首先创建pthread_t类型数组
* 循环创建线程个数，并赋给数组中的元素
* 将线程设置为脱离状态，不用单独对工作线程进行回收

##### 向请求队列中添加任务

通过list容器创建请求队列，向队列中添加时，通过互斥锁保证线程安全，添加完成后通过信号量提醒有任务要处理，最后注意线程同步

##### 线程处理函数

内部访问私有成员函数run，首先worker（线程处理函数）将参数强转为线程池类，调用成员方法run

##### run执行任务

工作线程从请求队列中取出某个任务进行处理，注意线程同步。

从请求队列中取出第一个任务，将任务从请求队列删除。

#### http处理流程

手下你对http报文处理的流程进行介绍，然后具体介绍http类的定义和服务器接收http请求的具体过程

##### http报文处理流程

* 浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应的buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理
* 工作线程取出任务后，调用process_read()函数，通过主从状态机对 请求报文进行解析
* 解析完后，跳转do_request函数生成响应报文，通过peocess_write写入buffer，返回给浏览器端。

##### http类

这里对read_once进行介绍，read_once读取浏览器端发送来的请求报文，直到无数据可读或对方关闭连接，读取到m_read_buffer中，并更新m_read_idx

##### epoll

* 非阻塞模式fcntl(fd,F_GETFL)
* 内核事件表注册新事件，开启EPOLLONESHOT,针对客户端连接的描述符，listenfd不用开启（通过）
* 内核事件表删除事件这两个都是通过epoll_ctl函数实现
* 重置EPOLLONESHOT事件

##### 服务器接收http请求

浏览器端发出http请求，主线程创建http对象接收请求并将所有数据读入对应的buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理

##### 状态机

从状态机负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机

流程图![640](G:\paper\640.jpg)

从状态机负责读取报文的一行，返回行读取状态，主状态机对行进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。

主状态机三种标识解析位置

* CHECK_STATE_REQUESTLINE,解析请求行
* CHECK_STATE_HEADER,解析请求头
* CHECK_STATE_CONTENT,解析消息体，仅用于解析post请求

从状态机：三种状态，标识解析一行的读取状态

* LINE_OK ，完整读取一行
* LINE_BAD，报文语法有误
* LINE_OPEN，读取的行不完整

##### http报文解析

浏览器端发出http连接请求，服务器端主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列后，工作线程从任务队列中取出一个任务进行处理。

各子线程通过process函数对任务进行处理，调用process_read()函数和process_write()函数分别完成报文解析和报文响应两个任务。

process_read()函数通过while循环，将主状态机进行封装，对报文的每一行进行循环处理

* 判断条件
  * 主状态机转移到CHECK_STATE_CONTENT,该条件设计解析消息体
  * 主状态机转移到line_ok，该条件涉及解析请求行和请求头部
  * 两者互为或关系，当条件真则继续循环，否则退出
* 循环体：
  * 从状态机读取数据
  * 调用get_line函数，通过m_start_line将从状态机读取数据间接赋给text

```c++
http_conn::HTTP_CODE http_conn::process_read()
 9{
10    //初始化从状态机状态、HTTP请求解析结果
11    LINE_STATUS line_status=LINE_OK;
12    HTTP_CODE ret=NO_REQUEST;
13    char* text=0;
14
15    //这里为什么要写两个判断条件？第一个判断条件为什么这样写？
16    //具体的在主状态机逻辑中会讲解。
17
18    //parse_line为从状态机的具体实现
19    while((m_check_state==CHECK_STATE_CONTENT && line_status==LINE_OK)||((line_status=parse_line())==LINE_OK))
20    {
21        text=get_line();
22
23        //m_start_line是每一个数据行在m_read_buf中的起始位置
24        //m_checked_idx表示从状态机在m_read_buf中读取的位置
25        m_start_line=m_checked_idx;
26
27        //主状态机的三种状态转移逻辑
28        switch(m_check_state)
29        {
30            case CHECK_STATE_REQUESTLINE:
        //从状态机line_ok了，且主状态机处于解析请求行状态，那么主状态机就调用请求行函数，进行解析请求行
        //解析完请求行，在parse_request_line函数中会把主状态机状态改为CHECK_STATE_HEADER，这样就实现状态转移了
        
31            {
32                //解析请求行
33                ret=parse_request_line(text);
34                if(ret==BAD_REQUEST)
35                    return BAD_REQUEST;
36                break;
37            }
38            case CHECK_STATE_HEADER:
39            {
40                //解析请求头
41                ret=parse_headers(text);
42                if(ret==BAD_REQUEST)
43                    return BAD_REQUEST;
44
45                //完整解析GET请求后，跳转到报文响应函数
46                else if(ret==GET_REQUEST)
47                {
48                    return do_request();
49                }
50                break;
51            }
52            case CHECK_STATE_CONTENT:
53            {
54                //解析消息体
55                ret=parse_content(text);
56
57                //完整解析POST请求后，跳转到报文响应函数
58                if(ret==GET_REQUEST)
59                    return do_request();
60
61                //解析完消息体即完成报文解析，避免再次进入循环，更新line_status
62                line_status=LINE_OPEN;
63                break;
64            }
65            default:
66            return INTERNAL_ERROR;
67        }
68    }
69    return NO_REQUEST;
70}
```

##### 从状态机逻辑

HTTP报文中，每一行的数据由\r\n作为结束符，空行仅仅是字符\r\n。因此可以通过查找\r\n将报文茶桔城单独的行进行解析。

从状态机负责取buffer中的数据，将每行数据末尾的\r\n置为\0\0，并更新从状态机在buffer中读取的位置m_checked_idx，以此来驱动主状态机解析。

* 从状态机从m_read_buf中逐字节读取，判断当前字节是否为\r
  * 接下来的字符是\n，将\r\n修改成\0\0,（说明是一行已经结束了，完整的一行），将m_checked_idx指向下一行的开头，则返回line_ok
  * 接下来达到了buffer末尾，表示buffer还需要继续接受返回Line_open
  * 否则表示语法错误，返回line_bad
* 当前字节不是\r，判断是否是\n（一般是上次读取到\r就到了buffer末尾，没有接收完整，再次接收时会出现这种情况）
  * 如果前一个字符是\r，则将\r\n修改为\0\0，将m_checked_idx指向下一行的开头，则返回line_ok
* 当前字节既不是\r也不是\n，
  * 表示接收不完整，需要继续接收，返回line_open

##### 主状态机逻辑

主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行末尾\r\n符号改为\0\0，以便于主状态机直接取出对应字符串进行处理

* CHECK_STATE_REQUESTLINE
  * 主状态机的初始状态，调用parse_request_line函数解析请求行
  * 解析函数从m_read_buf中解析HTTP请求行，获得请求方法、目标url以及HTTP版本号
  * 解析完成后主状态机的状态变为CHECK_STATE_HEADER

解析完请求行后，主状态机继续分析请求头。在报文中，请求头和空行的处理使用的是同一个函数，这里通过判断当前text首位是不是\0字符，若是，则表示当前处理的是空行，若不是，则表示当前处理的是请求头

* CHECK_STATE_HEADER
  * 调用parse_headers函数解析请求头部信息
  * 判断是空行还是请求头，若是空行，进而判断content_length是否为0，如果不是0，标明是POST请求，则状态转移到CHECK_STATE_CONTENT,否则说明是GET请求，则报文解析结束。
  * 若解析的是请求头部字段，则主要分析connection字段，content-length字段，其他字段可以直接跳过。
  * connection字段判断是keep-alive还是close，决定是长连接还是短连接

如果仅仅是GET请求，那么状态机只设置两个状态足矣。因为GET与post请求报文的区别之一是有无消息体部分，get请求有没有消息体，解析完空行之后，便完成了报文的解析

主状态机这里循环判断条件写成这样

`while((m_check_state==CHECK_STATE_CONTENT && line_status==LINE_OK)||((line_status=parse_line())==LINE_OK))`原因是在GET请求报文中，每一行都是\r\n作为结束，所以对报文进行拆解时，仅用从状态机的状态line_status=parse_line())==LINE_OK语句即可。

但，在POST请求报文中，消息体的末尾没有任何字符，所以不能使用从状态机的状态，这里转而使用主状态机的状态作为循环入口条件。那后面的&& line_status==LINE_OK，解析完消息体后，报文的完整解析就完成了，但此时主状态机的状态还是CHECK_STATE_CONTENT,也就是说，符合循环入口条件，还会再次进入循环。（因为已经是最后一个状态了，不会变了，就一直是这一个状态，所以一直会进入循环）。

* CHECK_STATE_CONTENT
  * 仅用于解析post请求，调用parse_content函数解析消息体
  * 用于保存post请求消息体，为后面的登录和注册做准备。







代码层面捋一下

1. 首先是子线程调用http中的process函数来处理任务

2. process函数又调用process_read()和process_write()来分别进行解析与响应

3. process_read()中循环读取每一行，交由从状态机来读取每一行，返回每一行的读取状态。

   在process_read()中初始化

   * 主状态机的CHECK_STATE_REQUESTLINE，如果从状态机读取到一个完整的行，并返回line_ok，那么主状态机就会进行调用parse_request_line来分析行里面的内容。然后将主状态机的状态设为CHECK_STATE_HEADER.

   * 然后进行下一次循环，从状态机读取一行，如果返回line_ok就调用parse_headers解析头部信息，解析完之后，如果是Get请求就直接跳转到响应函数do_request();是post请求就分析content部分
   * 当时post请求时，从状态机读取一个完整行，然后主状态机调用parse_content

至此，主从状态机完成http解析

#### HTTP响应

介绍几个基础API

* stat：用于取得指定文件的文件属性，并将文件属性存储在结构体stat中

  ```
  int stat(const char* pathname,struct stat* statbuf)
  struct stat{
  	mode_t st_mode;文件类型和权限
  	off_t st_size;文件大小、字节数
  }
  ```

* mmap:用于将一个文件或其他对象映射到内存，提高文件访问速度。

* iovec：定义一个向量元素，通常这个结构用作一个多元素的数组

* writev：函数用于在一次函数调用中写多个非连续缓冲区，有时也将这函数成为聚集写

##### do_request()

在主状态机中，分析完请求头之后，如果是get请求，那么直接调用do_request()函数。用来处理请求。do_request函数返回请求状态码，process_read()读取到状态吗后返回给process函数，process函数如果读到是BAD_REQUEST，那么就返回。如果是正常状态码，就process调用process_write来实现返回http响应。

##### process_write

根据do_request的返回状态，服务器子线程调用process_write向m_write中写入响应报文。

分别调用

* add_status_line函数
* add_headers函数添加消息报头
* add_blank_line添加空行

这些函数内部调用add_response函数更新m_write_idx指针和缓冲区m_write_buf中的内容。

##### http_conn:write:writing_hand:

服务器子线程调用process_write完成响应报文，随后注册epollout事件。服务器主线程检测写事件，并调用http_conn::write函数将响应报文发送给浏览器端。

发送逻辑：生成响应报文时初始化byte_to_send，包括头部信息和文件数据大小。通过writev函数循环发送响应报文数据，根据返回更新至byte_have_send和iovec结构体的指针和长度，并判断响应报文整体是否发送成功。

* 若writev单次发送成功，更新byte_to_send和byte_have_send的大小，若响应报文整体发送成功，则取消mmap映射，并判断是否是长链接
  * 长连接重置http类实例，注册读事件，不关闭连接
  * 短连接直接关闭连接
* 若writev单次发送不成功，判断是否是写缓冲区满了
  * 若不是满了而失败，取消mmap映射，关闭连接
  * 若eagain则满了，更新iovec结构体的指针和长度，并注册写事件，等待下一次写事件触发，因此在此期间无法立即接收到同一用户的下一请求，但可以保证连接的完整性

#### 定时器

项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中一次执行定时任务。

linux下提供了三种定时方法：

* socket选项： SO_RECVTIMEO和 SO_SNDTIMEO
* SIGALRM信号
* I/O复用系统调用的超时参数

在这个项目中使用的是SIGATRM信号。

利用alarm函数周期性地触发sigalrm信号，信号处理函数利用管道通知主循环，主循环接收到该信号后，对升序链表上所有定时器进行处理，若该段时间内没有数据交换，则将关闭连接释放资源。

##### 信号通知流程

linux下的信号采用的是异步处理机制，信号处理函数和当前进程是两条不同的执行路线。具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。

为避免信号竞态现象发生，信号处理期间系统不会再次触发，所以为确保信号不会被屏蔽太久，信号处理函数需要尽可能快的执行完毕。

一般信号处理函数需要处理信号的对应逻辑，当该逻辑比较复杂时候，信号处理函数执行事件过长会导致信号屏蔽时间太久。这里的解决方案是，信号处理函数仅仅发送信号通知主循环，将信号对应的逻辑放在程序主循环中，有主循环执行信号对应的逻辑代码。

##### 统一事件源

将信号事件与其他事件一样被处理

具体地信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，，主循环则从管道的读端读出信号值，使用I/O复用系统来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来检测，从而实现统一处理。

##### 信号处理函数

自定义信号处理函数，创建sigaction结构体变量，设置信号函数

```
void sig_handler(int sig)
 3{
 4    //为保证函数的可重入性，保留原来的errno
 5    //可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据
 6    int save_errno = errno;
 7    int msg = sig;
 8
 9    //将信号值从管道写端写入，传输字符类型，而非整型
10    send(pipefd[1], (char *)&msg, 1, 0);
11
12    //将原来的errno赋值为当前的errno
13    errno = save_errno;
14}
```

信号处理函数仅仅通过管道发送信号值，不处理信号对应的逻辑，缩短异步执行时间，减少对主程序的影响。

##### 信号通知逻辑

* 创建管道，其中管道写端写入信号值，管道读端通过I/O复用系统监测读事件
* 设置信号处理函数SIGALRM和SIGTERM
  * 通过sigaction结构体和sigaction函数注册信号捕捉函数
  * 在接头体的handler参数设置信号处理函数，具体的，从管道写端写入信号的名字。
* 利用I/O复用系统监听管道读端文件描述符的可读事件
* 信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码





这里讨论两个问题

* 管道写端要非阻塞：send试讲信息发送给套接字缓冲区，如果缓冲区满了，则 会阻塞，这时候进一步增加信号处理函数的执行时间，为此将其改为非阻塞。





#### 定时器设计

项目中将连接资源、定时事件和超时时间封装为定时器类

* 连接资源包括客户端套接字地址、文件描述符和定时器
* 定时事件为回调函数，将其封装起来由用户自定义，这里是删除非活动socket上的注册事件，并关闭
* 定时器超时时间=浏览器和服务器连接时刻+固定时间，可以看出，定时器使用绝对时间作为超时值，这里alarm设置为5s，连接超时为15s。

```c++
定时器类
struct client_data
 7{
 8    //客户端socket地址
 9    sockaddr_in address;
10
11    //socket文件描述符
12    int sockfd;
13
14    //定时器
15    util_timer* timer;
16};

//定时器类
19class util_timer
20{
21public:
22    util_timer() : prev( NULL ), next( NULL ){}
23
24public:
25    //超时时间
26    time_t expire; 
27    //回调函数
28    void (*cb_func)( client_data* );
29    //连接资源
30    client_data* user_data;
31    //前向定时器
32    util_timer* prev;
33    //后继定时器
34    util_timer* next;
35};
```

##### 定时器容器设计

带头尾节点的升序双向链表，具体的为每一个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排列。执行定时任务时，将到期的定时器从链表中删除。

主要涉及双向链表的插入删除操作，其中添加定时器的事件复杂度是o(n)，删除定时器的时间复杂度是o(1).

升序双向链表具体逻辑如下

* 创建头尾节点，其中头尾节点没有意义，仅仅统一方便调整
* add_timer函数，将目标定时器添加到链表中，添加时按照升序添加
  * 当前链表中只有头尾结点，直接插入
  * 否则将定时器按升序插入
* adjust_timer函数，当定时任务发生变化，调整对应定时器在链表中的位置
  * 客户端在设定时间内有数据收发，则当前时刻对该定时器重新设定事件，这里只是往后延长超时时间
  * 被调整的目标定时器在尾部，或定时器新的超时值仍然小于下一个定时器的超时，不用调整
  * 否则现将定时器从链表取出，重新插入链表
* del_timer函数将超时的定时器从链表中删除
  * 双向链表删除节点

##### 定时任务处理函数

使用统一事件源，将SIGALRM信号每次被处罚，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。

具体逻辑如下：

* 遍历定时器升序链表容器，从头节点开始一次处理每个定时器，直到遇到尚未到期的定时器
* 若当前时间小于定时器超时时间，跳出循环，即未找到到期的定时器
* 若当前时间大于定时器超时时间，即找到了到期的定时器，执行回调函数，然后将它从链表中删除，然后继续遍历

##### 定时器使用原理

服务器首先创建定时器容器链表，然后使用统一事件源将异常事件、读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器

* 浏览器与服务器连接时，穿件该连接对应的定时器，并将该定时器添加到链表上
* 处理异常事件时，执行定时事件，服务器关闭连接，从链表上溢出对应定时器
* 处理定时信号时，将定时标志设置为true
* 处理定时信号时，将定时标志设置为true
* 处理读事件时，若连接上发生了读事件，将定时器事件向后移动，否则执行定时事件
* 处理写事件，若服务器上发生读事件，将对应定时器向后移动，否则执行定时事件。

#### 日志系统

* 同步日志：日志写入函数与工作线程串行执行，由于设计到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈
* 生产者—消费者模型：并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区push消息，消费者线程从缓冲区中pop消息
* 阻塞队列：将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区
* 异步日志：将所有写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志
* 单例模式：保证一个类只创建一个实例，同时提供全局访问的方法。

##### 条件变量与生产者-消费者模型

**条件变量API与陷阱**

条件变量提供了一种线程间的通知机制，当某个共享数据打到某个值时，唤醒等待这个共享数据的线程。

* pthread_cond_init，用于初始化条件变量
* pthread_cond_destroy函数，销毁条件变量
* pthread_cond_broadcast函数，以广播的方式唤醒所有等待目标条件变量的线程
* pthread_cond_wait函数，用于等待目标条件变量。该函数调用时需要传入mutex参数，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回0时，表示重新抢到了互斥锁，互斥锁会再次被锁上，也就是说函数内会有一次解锁和加锁。

**阻塞队列**

阻塞队列中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者。
