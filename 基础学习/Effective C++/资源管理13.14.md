### 资源管理

#### 13：以对象管理资源

```c++
例子：假设一个类
class Investment{};
然后通过一个工厂函数供应特定的Investment对象，
Investment * creatInvestment();//返回指针，指向Investment继承涕泪的动态分配对象，调用者需要自己删除他。
现在有一个函数履行删除对象的任务
void f(){
	Investment *pInv=createInvestment();
    。。。
	delete pInv;
}
```

上面这种情况看起来没问题，但是如果没有调用函数f(),或者函数体内出现异常，提前return等情况就会没有执行delete语句。所以单纯的依赖于delete是没有用的。

为确保对象总会被释放，需要将资源放进对象内，析构函数会自动释放内存，确保资源被释放。

使用智能指针是一种方式，智能指针是一种类指针，使用结束会自动释放所指对象内存。

```
void f(){
	std::auto_ptr<Investment>pInt(createInvestment());
	...
}
```

这个例子示范了“获得资源后立刻放进管理对象”两个想法

* 获得资源后立刻放进管理对象内，
* 管理对象运用析构函数确保资源被释放。尽管析构函数中资源释放导致抛出异常，但是条款8解决了这个问题（停止程序或者吞下异常）

auto_ptr被销毁时会自动删除他所指之物，所以一定要注意别让多个auto_ptr指向同一个对象，所以auto_ptrs(注意这不一样)解决这个问题：若通过copy构造函数或copy assignment操作符复制他们，他们会编程null而复制所得指针将取得资源的唯一拥有权。（这不就是unique_ptr吗？智能指针我还没有具体的去学习只是学习了个大概，他们的作用，他们的实现原理需要去学习一下）

auto_ptr的替代方案是“引用计数型智能指针”

```
例如使用shared_ptr
void f(){
	std::tr1::shared_ptr<Investment>
	pIn(createInvestment());
	...
}
他们可以实现复制。
```

值得注意的是，auto_ptr,shared_ptr两个都是在析构函数内delete而不是delete[]（指的删除整个数组），所以要删除动态分配的数组，这样是不行的，还是需要一个个的delete