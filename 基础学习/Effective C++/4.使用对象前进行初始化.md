#### 4.使用对象前进行初始化

未进行初始化的变量，在某些语境下会自动初始化，有的会产生一个垃圾值。为了解决这种不确定性，就是要永远在使用对象之前将其初始化。

1. 使用构造函数进行初始化

   确保每一个构造函数都将对象的每一个成员初始化。

   但是使用构造函数进行初始化的时候，赋值(assignment)与初始化(initialization)是有区别的；

   ````
   class PhoneNumber{
   private:
   	string name;
   	int age;
   public :
   	PhoneNumber(string name,int age){//这种叫做赋值，并不叫初始化，因为初始化发生在进入构造函数
   										本体之前。初始化时间更早一点。
   		this->name=name;
   		this->age=age;
   	}
   }
   //较好的一个写法就是使用成员列表进行赋值例如
   PhoneNumber(string name,int age):
   this->name(name),//这种叫做初始化。
   this->age(age){
   //构造函数本体不会有任何动作
   }
   
   这样效率更高，因为上一个是先调用默认构造函数进行赋初值，然后再赋予新值。这样默认构造函数就完全的浪费了，相当于白白运行了一遍默认构造函数。
   
   成员初值列的做法避免了这一问题，因为初值列中针对各个成员变量而设的实参，被拿去作为各个成员变量之构造函数的实参。
   要注意总是在出之列中列出所有的成员变量，以免忘记了那些赋初值，哪些没有。
   ````
   
   2.对于const和reference也必须赋初值，不能进行赋值，因为const和reference是不可变的
   
   

3. C++初始化顺序

	*  基类早于派生类
	*  成员变量以其声明次序被初始化，以免引起某些变量使用时出现空值，例如初始化数组长度，而这个长度需要在后面被使用到，但是长度并没有被初始化。

4 .在跨文件使用static对象的时候，尽量使用单例，以保证使用的对象已经进行了初始化。

​	

